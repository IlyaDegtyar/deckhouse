# Для чего используется данный файл?

Файл werf-debug.yaml содержит инструкции для автоматической сборки и разворачивания Docker-образа приложения `deckhouse-web`. Вы можете использовать этот файл как непосредственно для этой цели, так и в качестве шаблона для  создания файла конфигурации для сборки и разворачивания своих Docker-образов. Задачи, выполняемые с помощью конфигураций в данном файле, выполняются последовательно. Тем не менее, для удобства понимания и  редактирования этих конфигураций, в настоящем руководстве они разделяются в соответствии со следующими группами задач:

- Конфигурация базового образа: Динамическое разрешение версий образов
  
- Создание артефакта web-static: Подготовка статических файлов

- Конфигурация образа Docker для бэкенда

- Сборка Docker-образа web-frontend

В качестве примеров реализации данных задач приводятся фрагменты конфигурации из файла werf-debug.yaml.

# Конфигурация и развёртывание Docker-образов c помощью файла YAML

## Конфигурация базового образа: Динамическое разрешение версий образов

1. Укажите значение переменной образа Docker с помощью инструкции шаблона языка Go. Значение состоит из следующих элементов:

- версия языка Go
- версия дистрибутива Linux
- ID Docker-образа

**Пример**

```{{ $BASE_GOLANG_16_BUSTER := "golang:1.16.3-buster@sha256:9d64369fd3c633df71d7465d67d43f63bb31192193e671742fa1c26ebc3a6210" }}```

2. Укажите имя и версию проекта

**Пример**

```
project: deckhouse-web
configVersion: 1
```

3. Загрузите версии образов из файла  из каталога `../../candi/image_versions.yml`.

4. Формирование полного пути к базовым образам путём добавления пути к реестру (указанного в переменной .Images.REGISTRY_PATH) к имени каждого образа. Символ прямой косой черты в конце пути удаляется.

5. Адаптируйте пути к образу в зависимости от среды. Если процесс сборки происходит в среде разработки (development) или для конкретного модуля (module), путь к образу корректируется. В этом случае из полного пути к образу удаляется тег версии, оставляя только имя образа. Это позволяет использовать более общие или разрабатываемые версии образов в указанных средах.

6. Обновление списка образов: После формирования конечного пути к каждому образу, информация об образах обновляется в используемой конфигурации. Однако путь к самому реестру образов (REGISTRY_PATH) не изменяется, чтобы сохранить его целостность для всех образов.
	
**Пример**

{{ $_ := set . "Images" (.Files.Get "../../candi/image_versions.yml" | fromYaml) }}
  {{- range $k, $v := .Images }}
    {{ $baseImagePath := (printf "%s%s" $.Images.REGISTRY_PATH (trimSuffix "/" $v)) }}
    {{- if or (eq $.Env "development") (eq $.Env "module") }}
      {{ $baseImagePath = trimSuffix "/" $v | splitList "@" | first }}
    {{- end }}
    {{- if ne $k "REGISTRY_PATH" }}
      {{- $_ := set $.Images $k $baseImagePath }}
    {{- end }}
  {{- end }}

## Создание артефакта web-static: Подготовка статических файлов

На этом шаге задаются параметры для сборки статического веб-сайта с помощью Jekyll. Для установки зависимостей (таких как `rsync` и `bundler`) и создания статических файлов используется Ansible. Кроме того, с помощью Git в статический контент интегрируется документация и из процесса сборки исключаются определенные директории.

1. Укажите имя артефакта с помощью пары `ключ: значение`

2. Задайте исходный образ для сборки

3. Задайте автоматическую установку и обновление необходимых утилит.

4. Задайте для переменной окружения `JEKYLL_ENV` значение `production`.

5. Создайте переменную директорию для процесса сборки с полными правами (777).

6. Выполните команду jekyll build

**Пример**
```
artifact: web-static
from: {{ .Images.BASE_JEKYLL }}
ansible:
  install:
    - shell: |
        apk add rsync
        gem update bundler
    - name: "Install Dependencies"
      shell: bundle install
      args:
        executable: /bin/bash
        chdir: /srv/jekyll-data/site/
  beforeSetup:
    - name: "Build static files"
      shell: |
        export JEKYLL_ENV=production
        mkdir -m 777 -p /app/_site/
        jekyll build -d /app/_site/ --config _config.yml --trace
      args:
        executable: /bin/bash
        chdir: /srv/jekyll-data/site/
```	
7. Задайте команду добавления содержимого директории /doc/site в контекст сборки.

8. Укажите путь к директории, в которой должен быть размещен контент из /doc/site/.

9. Задайте пользователя и группу для владельца контента как `jekyll` для доступа и модификации файлов.

10. Укажите пути, которые должны быть исключены из процесса сборки как `excludePaths`.

11. Укажите файлы, любое изменение в которых запускает процесс инсталляции, например `Gemfile` и `Gemfile.lock`.

12. Укажите файлы, любое изменение в которых должно запустить задачи стадии `beforeSetup`.

**Пример**

git:
- add: /docs/site
  to: /srv/jekyll-data/site
  owner: jekyll
  group: jekyll
  excludePaths:
  - '**/*.sh'
  - LOCAL_DEV.md
  - werf*.yaml
  - docker-compose*.yml
  - .werf
  - .helm
  - backend
  - Makefile
  stageDependencies:
    install: ['Gemfile','Gemfile.lock']
    beforeSetup: '**/*'

### Конфигурация образа Docker для бэкенда

На этом шаге описывается создание Docker-образа `web-backend`, указывается использование базового образа Golang и настраивается рабочий каталог. С помощью задач Ansible обновляются системные пакеты, устанавливаются необходимые инструменты и подготавливается среда Go. Шаг также включает компиляцию Go-приложения и интеграцию внешних Git-репозиториев. Ранее созданный артефакт `web-static`, размещается в файловой структуре бэкенд-приложения.

1. Задайте идентификатор для Docker образа. В рассматриваемом примере это бэкенд приложения `deckhouse-web`.

2. Укажите базовый Docker образ, который будет использоваться для сборки.

3. С помощью директивы `fromCacheVersion` укажите версию кэша для сборки образа.

4. Блок конфигурации `docker` содержит путь к рабочей директории в контейнере. Это директория, в которой будет размещаться и выполняться приложение `web-backend`. В нашем примере директория задана как /app.

5. Блок конфигурации `ansible` содержит задачи, выполняемые Ansible для настройки окружения и сборки приложения. В примере ниже выполняются следующие задачи:

* `apt update & apt install` - обновления базы данных пакетов и установка необходимых инструментов

* `go mod tidy`- добавление недостающих и удаление лишних модулей

* `go get ithub.com/go-delve/delve/cmd/dlv` - установка дебаггера Delve

6. Раздел `setup` содержит конфигурацию задач для сборки приложения, реализующего функции HTTP-сервера для сайта. Флаги сборки в настоящем примере используются для отладки и подробного логирования.

7. Набор инструкций для интеграции исходного кода содержится в разделе `git`. Аргументы задаются при помощи `args`.

**Пример**

```
image: web-backend
from: {{ $BASE_GOLANG_16_BUSTER }}
fromCacheVersion: 20210701
docker:
  WORKDIR: /app
ansible:
  install:
    - shell: apt update && apt install -yq git curl jq
    - shell: |
        go mod tidy
        go get github.com/go-delve/delve/cmd/dlv
      args:
        executable: /bin/sh
        chdir: /go/src/app
  setup:
    - shell: |
        go build -gcflags "all=-N -l" -v -o /app/server /go/src/app/cmd/v-router
      args:
        executable: /bin/sh
        chdir: /go/src/app
git:
  - url: https://github.com/flant/web-router.git
    tag: v1.0.14
    add: /
    to: /go/src/app
    stageDependencies:
      install: 'go.mod'
      setup: '**/*'
	  
import:
  - artifact: web-static
    add: /app/_site
    to: /app/root
    before: setup
```

## Сборка Docker-образа web-frontend

В данном разделе описывается процесс создания Docker-образа `web-frontend` для фронтенда разворачиваемого приложения. Выполняется определение базового образа, настройка рабочей директории, конфигурация образа при помощи Ansible и импорт артефактов.

1. Задайте имя образа с помощью пары `ключ-значение` (`image: web-frontend`).

2. Задайте рабочая директория /app в Docker-контейнере. В этой директории будут располагаться все файлы и директории приложения.

3. `from: {{ .Images.BASE_NGINX_ALPINE }}` определяет базовый образ для создания контейнера.

4. Раздел `ansible` содержит описание копирования конфигурационного файла NGINX из файла `.werf/nginx.conf` в файл `/etc/nginx/nginx.conf` внутри контейнера.

5. Опишите процесс импорта артефактов в разделе `import`:

- задайте имя артефакта
- укажите исходную и целевую директории импорта
- укажите, что импорт должен быть выполнен до задач настройки через Ansible
- задайте имя пользователя и группы владельца импортированных файлов
- укажите список путей, которые будут исключены из импорта.

**Пример**

```
image: web-frontend   
docker:
  WORKDIR: /app        
from: {{ .Images.BASE_NGINX_ALPINE }}  
ansible:
  setup:
  - name: "Copy nginx.conf"
    copy:
      content: |
        {{- .Files.Get ".werf/nginx.conf" | nindent 8 }}
      dest: /etc/nginx/nginx.conf
import:
- artifact: web-static 
  add: /app/_site    
  to: /app
  before: setup
  owner: nginx
  group: nginx
  excludePaths:
  - en/includes/
  - ru/includes/
```
